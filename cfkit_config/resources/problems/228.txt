Codeforces Round 141 (Div. 2)


A. Is your horseshoe on the other hoof?
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Valera the Horse is going to the party with friends. He has been following the fashion trends for a while, and he knows that it is very popular to wear all horseshoes of different color. Valera has got four horseshoes left from the last year, but maybe some of them have the same color. In this case he needs to go to the store and buy some few more horseshoes, not to lose face in front of his stylish comrades.
Fortunately, the store sells horseshoes of all colors under the sun and Valera has enough money to buy any four of them. However, in order to save the money, he would like to spend as little money as possible, so you need to help Valera and determine what is the minimum number of horseshoes he needs to buy to wear four horseshoes of different colors to a party.
Input
The first line contains four space-separated integers
s
1
,
s
2
,
s
3
,
s
4
(1 ≤
s
1
,
s
2
,
s
3
,
s
4
≤ 10
9
)
— the colors of horseshoes Valera has.
Consider all possible colors indexed with integers.
Output
Print a single integer — the minimum number of horseshoes Valera needs to buy.
Examples
Input
1 7 3 3
Output
1
Input
7 7 7 7
Output
3
----------------------------------------------------------------------------------------------------
B. Two Tables
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You've got two rectangular tables with sizes
n
a
×
m
a
and
n
b
×
m
b
cells. The tables consist of zeroes and ones. We will consider the rows and columns of both tables indexed starting from 1. Then we will define the element of the first table, located at the intersection of the
i
-th row and the
j
-th column, as
a
i
,
j
; we will define the element of the second table, located at the intersection of the
i
-th row and the
j
-th column, as
b
i
,
j
.
We will call the pair of integers
(
x
,
y
)
a
shift
of the second table relative to the first one. We'll call the
overlap factor
of the shift
(
x
,
y
)
value:
where the variables
i
,
j
take only such values, in which the expression
a
i
,
j
·
b
i
+
x
,
j
+
y
makes sense. More formally, inequalities
1 ≤
i
≤
n
a
, 1 ≤
j
≤
m
a
, 1 ≤
i
+
x
≤
n
b
, 1 ≤
j
+
y
≤
m
b
must hold. If there are no values of variables
i
,
j
, that satisfy the given inequalities, the value of the sum is considered equal to 0.
Your task is to find the shift with the maximum overlap factor among all possible shifts.
Input
The first line contains two space-separated integers
n
a
,
m
a
(1 ≤
n
a
,
m
a
≤ 50)
— the number of rows and columns in the first table. Then
n
a
lines contain
m
a
characters each — the elements of the first table. Each character is either a "
0
", or a "
1
".
The next line contains two space-separated integers
n
b
,
m
b
(1 ≤
n
b
,
m
b
≤ 50)
— the number of rows and columns in the second table. Then follow the elements of the second table in the format, similar to the first table.
It is guaranteed that the first table has at least one number "
1
". It is guaranteed that the second table has at least one number "
1
".
Output
Print two space-separated integers
x
,
y
(|
x
|, |
y
| ≤ 10
9
)
— a shift with maximum overlap factor. If there are multiple solutions, print any of them.
Examples
Input
3 2
01
10
00
2 3
001
111
Output
0 1
Input
3 3
000
010
000
1 1
1
Output
-1 -1
----------------------------------------------------------------------------------------------------
C. Fractal Detector
time limit per test
4 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Little Vasya likes painting fractals very much.
He does it like this. First the boy cuts out a
2 × 2
-cell square out of squared paper. Then he paints some cells black. The boy calls the cut out square a fractal
pattern
. Then he takes a clean square sheet of paper and paints a fractal by the following algorithm:
He divides the sheet into four identical squares. A part of them is painted black according to the fractal pattern.
Each square that remained white, is split into 4 lesser white squares, some of them are painted according to the fractal pattern. Each square that remained black, is split into 4 lesser black squares.
In each of the following steps step 2 repeats. To draw a fractal, the boy can make an arbitrary positive number of steps of the algorithm. But he need to make at least two steps. In other words step 2 of the algorithm
must be done at least once
. The resulting picture (the square with painted cells) will be a fractal. The figure below shows drawing a fractal (here boy made three steps of the algorithm).
One evening Vasya got very tired, so he didn't paint the fractal, he just took a sheet of paper, painted a
n
×
m
-cell field. Then Vasya paint some cells black.
Now he wonders, how many squares are on the field, such that there is a fractal, which can be obtained as described above, and which is equal to that square. Square is considered equal to some fractal if they consist of the same amount of elementary not divided cells and for each elementary cell of the square corresponding elementary cell of the fractal have the same color.
Input
The first line contains two space-separated integers
n
,
m
(2 ≤
n
,
m
≤ 500)
— the number of rows and columns of the field, correspondingly.
Next
n
lines contain
m
characters each — the description of the field, painted by Vasya. Character "
.
" represents a white cell, character "
*
" represents a black cell.
It is guaranteed that the field description doesn't contain other characters than "
.
" and "
*
".
Output
On a single line print a single integer — the number of squares on the field, such that these squares contain a drawn fractal, which can be obtained as described above.
Examples
Input
6 11
......*.***
*.*.*....**
.***....*.*
..***.*....
.*.*.....**
......*.*..
Output
3
Input
4 4
..**
..**
....
....
Output
0
----------------------------------------------------------------------------------------------------
D. Zigzag
time limit per test
3 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
The court wizard Zigzag wants to become a famous mathematician. For that, he needs his own theorem, like the Cauchy theorem, or his sum, like the Minkowski sum. But most of all he wants to have his sequence, like the Fibonacci sequence, and his function, like the Euler's totient function.
The Zigag's sequence with the zigzag factor z is an infinite sequence
S
i
z
(
i
≥ 1;
z
≥ 2)
, that is determined as follows:
S
i
z
= 2
, when
;
, when
;
, when
.
Operation
means taking the remainder from dividing number
x
by number
y
. For example, the beginning of sequence
S
i
3
(zigzag factor 3) looks as follows: 1, 2, 3, 2, 1, 2, 3, 2, 1.
Let's assume that we are given an array
a
, consisting of
n
integers. Let's define element number
i
(1 ≤
i
≤
n
)
of the array as
a
i
. The Zigzag function is function
, where
l
,
r
,
z
satisfy the inequalities
1 ≤
l
≤
r
≤
n
,
z
≥ 2
.
To become better acquainted with the Zigzag sequence and the Zigzag function, the wizard offers you to implement the following operations on the given array
a
.
The assignment operation. The operation parameters are
(
p
,
v
)
. The operation denotes assigning value
v
to the
p
-th array element. After the operation is applied, the value of the array element
a
p
equals
v
.
The Zigzag operation. The operation parameters are
(
l
,
r
,
z
)
. The operation denotes calculating the Zigzag function
Z
(
l
,
r
,
z
)
.
Explore the magical powers of zigzags, implement the described operations.
Input
The first line contains integer
n
(1 ≤
n
≤ 10
5
)
— The number of elements in array
a
. The second line contains
n
space-separated integers:
a
1
,
a
2
, ...,
a
n
(1 ≤
a
i
≤ 10
9
)
— the elements of the array.
The third line contains integer
m
(1 ≤
m
≤ 10
5
)
— the number of operations. Next
m
lines contain the operations' descriptions. An operation's description starts with integer
t
i
(1 ≤
t
i
≤ 2)
— the operation type.
If
t
i
= 1
(assignment operation), then on the line follow two space-separated integers:
p
i
,
v
i
(1 ≤
p
i
≤
n
; 1 ≤
v
i
≤ 10
9
)
— the parameters of the assigning operation.
If
t
i
= 2
(Zigzag operation), then on the line follow three space-separated integers:
l
i
,
r
i
,
z
i
(1 ≤
l
i
≤
r
i
≤
n
; 2 ≤
z
i
≤ 6)
— the parameters of the Zigzag operation.
You should execute the operations in the order, in which they are given in the input.
Output
For each Zigzag operation print the calculated value of the Zigzag function on a single line. Print the values for Zigzag functions in the order, in which they are given in the input.
Please, do not use the
%lld
specifier to read or write 64-bit integers in С++. It is preferred to use
cin
,
cout
streams or the
%I64d
specifier.
Examples
Input
5
2 3 1 5 5
4
2 2 3 2
2 1 5 3
1 3 5
2 1 5 3
Output
5
26
38
----------------------------------------------------------------------------------------------------
E. The Road to Berland is Paved With Good Intentions
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Berland has
n
cities, some of them are connected by bidirectional roads. For each road we know whether it is asphalted or not.
The King of Berland Valera II wants to asphalt all roads of Berland, for that he gathered a group of workers. Every day Valera chooses exactly one city and orders the crew to asphalt all roads that come from the city. The valiant crew fulfilled the King's order in a day, then workers went home.
Unfortunately, not everything is as great as Valera II would like. The main part of the group were gastarbeiters — illegal immigrants who are enthusiastic but not exactly good at understanding orders in Berlandian. Therefore, having received orders to asphalt the roads coming from some of the city, the group asphalted all non-asphalted roads coming from the city, and vice versa, took the asphalt from the roads that had it.
Upon learning of this progress, Valera II was very upset, but since it was too late to change anything, he asked you to make a program that determines whether you can in some way asphalt Berlandian roads in at most
n
days. Help the king.
Input
The first line contains two space-separated integers
n
,
m
— the number of cities and roads in Berland, correspondingly. Next
m
lines contain the descriptions of roads in Berland: the
i
-th line contains three space-separated integers
a
i
,
b
i
,
c
i
(1 ≤
a
i
,
b
i
≤
n
;
a
i
≠
b
i
; 0 ≤
c
i
≤ 1)
. The first two integers
(
a
i
,
b
i
)
are indexes of the cities that are connected by the
i
-th road, the third integer
(
c
i
)
equals 1, if the road was initially asphalted, and 0 otherwise.
Consider the cities in Berland indexed from 1 to
n
, and the roads indexed from 1 to
m
. It is guaranteed that between two Berlandian cities there is not more than one road.
Output
In the first line print a single integer
x
(0 ≤
x
≤
n
)
— the number of days needed to asphalt all roads. In the second line print
x
space-separated integers — the indexes of the cities to send the workers to. Print the cities in the order, in which Valera send the workers to asphalt roads. If there are multiple solutions, print any of them.
If there's no way to asphalt all roads, print "
Impossible
" (without the quotes).
Examples
Input
4 4
1 2 1
2 4 0
4 3 1
3 2 0
Output
4
3 2 1 3
Input
3 3
1 2 0
2 3 0
3 1 0
Output
Impossible
----------------------------------------------------------------------------------------------------
